The following summarizes some off-line discussion between Leonardo @Leonardo2718, Annabelle @a7ehuo, Daryl @0xdaryl and myself.

In the prototype implementation of value types, a field whose type is a value type might be flattened by the JVM.  The contents of such a field will be held directly in the containing object.

For resolution of a field whose type is not a value type, the IL will contain a `ResolveCHK` operation whose child is a memory reference with the appropriate form.  For example, for the reference to `o.v`, in the following

```
public class Holder {Object v;}
public class Toy {
   public static Object sub(Holder o) {return (o == null) ? null : o.v;}
}
```

the IL will look like this

```
n18n   ResolveCHK [#32]
n17n     aloadi  LHolder.v Ljava/lang/Object;
n16n       aload  <parm 0 LHolder;>  // Load of "o"
```

In the case of an unresolved field of value type, as the field might be flattened in the containing object, the JIT will not be able to construct a simple memory reference for the field.  If the field and its type have been resolved, the JIT is able to inquire of the JVM how the contents of that field are stored in an instance of the containing class, and will generate loads or stores of the individuals parts of the flattened field of value type.  Alternatively, the JIT is also able to generate calls to JVM helpers to retrieve the value from the flattened field or to store the value to the flattened field.  Which is chosen is determined by the settings of the `useFlattenedFieldRuntimeHelpers` and `dontUseFlattenedFieldRuntimeHelpers` JIT options.

In the following example, if the `v` field of `Holder` is flattened, and the JIT is generating calls to the JVM flattened field helpers

```
public value Point {double x, y;}
public class Holder {Point v;}
public class Toy {
   public static Object sub(Holder o) {return (o == null) ? null : o.v;}
}
```

the IL generated by the JIT looks like this

```
n21n   treetop
n20n     acall  jitGetFlattenableField
n16n       aload  <parm 0 LHolder;>   // Load of "o"
n17n       aconst 0x17e210   // cp()+cpIndex
```

The JVM team will provide a runtime helper, `jitResolveFlattenableField`, that the JIT can use to perform the resolution of a field whose type is a value type, as described in #11570

> ValueTypes: Add jit runtime helper to resolve field refs for flattenable fields:  
> 
>   Params:
>     J9VMThread currentThread: implicit param
>     J9Method method: method in which the resolution must take place
>     U_32 cpIndex: ram constant pool index for the field ref
>     U_32 resolveType: one of J9TR_FLAT_RESOLVE_WITHFIELD / J9TR_FLAT_RESOLVE_GETFIELD / J9TR_FLAT_RESOLVE_PUTFIELD
> 
>     For U_32 parameters on 64-bit platforms, the high-order 32 bits are unused.


The JVM helpers `jit{Get|Put|With}FlattenableField` are able to handle fields whether they are actually flattened or not, so the JIT can generate a call to use one of those helpers for any unresolved field that is of a value type, despite not having information about the actual layout of the field.  So, the idea would be for the JIT to generate code for a call to a snippet that would call `jitResolveFlattenableField` to perform the resolution, and then patch the mainline call to the snippet with a `nop`, so that the resolution would likely only be performed once at that point in the code.  That snippet call would be followed by the call to `jit{Get|Put|With}FlattenableField`.

The question to be resolved in this issue is how to represent the required resolve check operation in the IL, as there would be no explicit memory reference in the IL with which to associate the resolve check of the field - just a helper call.  We discussed two possibilities:

1. Using a call to a non-helper symbol, say `valueTypeFieldResolveCHK`, whose arguments would be the `cpIndex` and the kind of operation
```
    n99n   treetop
    n98n     acall  valueTypeFieldResolveCHK
    n97n       iconst 5  // cpIndex
    n96n       iconst 1  // J9TR_FLAT_RESOLVE_GETFIELD
    n21n   treetop
    n20n     acall  jitGetFlattenableField
    n16n       aload  <parm 0 LHolder;>
    n17n       aconst 0x17e210   // cp()+cpIndex
 ```
     
2. Defining a new ValueTypeFieldResolveCHK opcode with operands being the `cpIndex` and the kind of operation involved:
```
    n99n   ValueTypeFieldResolveCHK
    n98n     iconst 5  // cpIndex
    n97n     iconst 1  // J9TR_FLAT_RESOLVE_GETFIELD
    n21n   treetop
    n20n     acall  jitGetFlattenableField
    n16n       aload  <parm 0 LHolder;>
    n17n       aconst 0x17e210   // cp()+cpIndex
 ```
