I will use the following as an example of a more pervasive question, related to #277 

```
 ./build/linux-x86_64-normal-server-release/jdk/bin/java '-Xjit:useIlValidator,limit={com/ibm/jit/JITHelpers.getClassDepthAndFlagsFromJ9Class64(J)J}'  -version 
*** VALIDATION ERROR ***
Node: lloadi n5n
Method: com/ibm/jit/JITHelpers.getClassDepthAndFlagsFromJ9Class64(J)J
Child 0 has unexpected type Int64 (expected Address)
openjdk version "9-internal"
OpenJDK Runtime Environment (build 9-internal+0-adhoc..sandbox)
Eclipse OpenJ9 VM (build 2.9, JRE 9 Linux amd64-64 Compressed References 20171025_000000 (JIT enabled, AOT enabled)
OpenJ9   - e4e4e86
OMR      - 604be15
OpenJDK  - 2cc4359 based on jdk-9+181)
``` 

Looking at the trees generated by this method, we see 

```

Pre IlGenOpt Trees: for com/ibm/jit/JITHelpers.getClassDepthAndFlagsFromJ9Class64(J)J


--------------------

n1n       BBStart <block_2>                                                                   [0x7f75dab4fde0] bci=[-1,0,-] rc=0 vc=0 vn=- li=- udi=- nc=0
n6n       treetop                                                                             [0x7f75dab4ff70] bci=[-1,0,-] rc=0 vc=0 vn=- li=- udi=- nc=1
n5n         lloadi  <isClassAndDepthFlags>[#563  Shadow +24] [flags 0x603 0x0 ]               [0x7f75dab4ff20] bci=[-1,0,-] rc=2 vc=0 vn=- li=- udi=- nc=1
n4n           lload  <parm 1 J>[#634  Parm] [flags 0x40000104 0x0 ]                           [0x7f75dab4fed0] bci=[-1,0,-] rc=1 vc=0 vn=- li=- udi=- nc=0
n8n       lreturn                                                                             [0x7f75dab50010] bci=[-1,0,-] rc=0 vc=0 vn=- li=- udi=- nc=1
n5n         ==>lloadi
n2n       BBEnd </block_2>                                                                    [0x7f75dab4fe30] bci=[-1,0,-] rc=0 vc=0 vn=- li=- udi=- nc=0
```

As you can see, the `lloadi` has an `lload` child. This makes sense, given that the JITHelper method has the signature 

```
public native long getClassDepthAndFlagsFromJ9Class64(long j9clazz);
```

and it's java, so there's no alternative to exposing an "address" type in that signature. However, `lloadi` is documented to take an Address type, so the validator fails. 

The replacement [is done in `VMJ9.cpp`, by converting the call opcode to an indirect load, and passing the second child through to the load directly](https://github.com/eclipse/openj9/blob/ebd3409295a62f9b42d1fecfeefc739788981c41/runtime/tr.source/trj9/env/VMJ9.cpp#L8384-L8458). 

It seems that the right answer here would be to inject an appropriate `l2a` (or `i2a`) conversion. However, I'm not sure what the rules are with regards to doing those conversions, doubly so with regards to the interaction between them and compressed references. 

**Is it generally safe to do `[l|I]2a`?**

I suspect this problem is relatively pervasive in that area of the code, looking at the JITHelpers interface. 