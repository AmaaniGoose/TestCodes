Currently in OMR there exists two scavenger scan orderings which determine the order in which objects are scanned and copied during a garbage collection. These two that currently exist are: OMR_GC_SCAVENGER_SCANORDERING_BREADTH_FIRST and OMR_GC_SCAVENGER_SCANORDERING_HIERARCHICAL.  Hierarchical scan ordering is much more complex than breadth first scan ordering and is also more performant. With the goal of implementing a scan ordering that is capable to perform at the level hierarchical but without the complexities that exist within hierarchical scan ordering, this third scavenger scan ordering called OMR_GC_SCAVENGER_SCANORDERING_DYNAMIC_BREADTH_FIRST is required.

This new scan ordering is going to be a layer on top of the existing breadth first scan ordering implementation. This dynamic breadth first scan ordering will use JIT information to determine the hot access paths (fields that are often accessed within a class) of an object and when a live object is being copied during a garbage collection, the scavenger will recursively copy the hot fields of the object currently being copied (if any hot fields exist) along with the hot fields of the hot fields etc. until a class containing zero hot fields in reached. At this time, Scavenger will continue to scan breadth first until another object that has marked hot fields is the object currently being copied and at that point the cycle repeats to recursively copy the hot fields of the object immediately after the parent object is copied. 

This scan ordering leads to better locality and faster mutator access times relative to breadth first scan ordering as in many cases, objects that are accessed are copied together.  This scan ordering has overall throughput performance directly comparable with hierarchical scan ordering and in some cases wins, along with a gc overhead that is lower than hierarchical scan ordering.  