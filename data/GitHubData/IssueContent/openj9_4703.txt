Currently JIT attached to a shadow symbol a property called Recognized Field that indicates the symbol is specially recognized by various JIT code. This is done at ILGen via pattern matching of the field and owning field names of the underlying reference field load.

PR https://github.com/eclipse/omr/pull/3433 optimizes a pattern `Field1 f1 = o.field1; if (f1==null) initialize_f1; Field2 f2 = f1.field2; if (f2==null) initialize_f2` where `o` is a known object. If value of `f1` is null, it is initialized just once to a valid non-null value and does not change; similarly, if `f2` is null, it is also initialized to a valid non-null value and also does not change during entire run time. Given `o` is known object, based on this program semantic, we can in turn treat `f1` as known object and `f2` in turn as known object as well. In the implementation. instead of perform class and field name pattern matching during VP, both `o.field1` and  `f1.field2` are recognized as recognized fields during ILGen; additionally a new flag is set on the symbol during symbol creation to indicate these fields as `Recognized Known Object Shadow`, such that user code of the underlying node knows if the base object is known object, the field object can be derived to be known object as well. Therefore, adding the `Recognized Known Object Shadow` symbol flag early on introduces a simple way to facilitate folding without additional pattern matching; moreover it would allow folding and traversal earlier in the optimization sequence.

In OpenJ9 code (e.g. `J9TransformUtil`), we have 3 kinds of 'shadows' can be folded/optimized: known object fields pointing to other known objects, known object fields pointing at representable native structs (eg natives that an address could be materialized) and final fields pointing at unrepresentable native structs (eg natives which can be dereferenced but which cannot be represented with a compile-time constant like a known object trusted field - the first case). Case in PR https://github.com/eclipse/omr/pull/3433 is essentially a variant of case 1, by annotating a symref with a flag rather than having a list of structured fields which we examine/pattern matching when doing folding. We should consider applying the same mechanism to the other two cases: possibly by introducing additional flags on the symbol early on at symbol creation time. Then user of the symbol in various optimization phases/passes can consume them instead